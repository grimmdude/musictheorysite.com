<!DOCTYPE html>

<html>
<head>
  <title>stavenote.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>stavenote.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="accidental.html">
                    accidental.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="annotation.html">
                    annotation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="articulation.html">
                    articulation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="barnote.html">
                    barnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="beam.html">
                    beam.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="bend.html">
                    bend.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="boundingbox.html">
                    boundingbox.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="boundingboxcomputation.html">
                    boundingboxcomputation.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="canvascontext.html">
                    canvascontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clef.html">
                    clef.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="clefnote.html">
                    clefnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="crescendo.html">
                    crescendo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="curve.html">
                    curve.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="dot.html">
                    dot.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="easyscore.html">
                    easyscore.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="element.html">
                    element.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="factory.html">
                    factory.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="formatter.html">
                    formatter.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="fraction.html">
                    fraction.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="frethandfinger.html">
                    frethandfinger.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ghostnote.html">
                    ghostnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="glyph.html">
                    glyph.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenote.html">
                    gracenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracenotegroup.html">
                    gracenotegroup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="gracetabnote.html">
                    gracetabnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="index.html">
                    index.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keymanager.html">
                    keymanager.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="keysignature.html">
                    keysignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifier.html">
                    modifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="modifiercontext.html">
                    modifiercontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="music.html">
                    music.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note.html">
                    note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="notehead.html">
                    notehead.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="notesubgroup.html">
                    notesubgroup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ornament.html">
                    ornament.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="parser.html">
                    parser.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="pedalmarking.html">
                    pedalmarking.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="raphaelcontext.html">
                    raphaelcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="registry.html">
                    registry.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="renderer.html">
                    renderer.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stave.html">
                    stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavebarline.html">
                    stavebarline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveconnector.html">
                    staveconnector.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavehairpin.html">
                    stavehairpin.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staveline.html">
                    staveline.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavemodifier.html">
                    stavemodifier.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavenote.html">
                    stavenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="staverepetition.html">
                    staverepetition.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavesection.html">
                    stavesection.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetempo.html">
                    stavetempo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetext.html">
                    stavetext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavetie.html">
                    stavetie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stavevolta.html">
                    stavevolta.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stem.html">
                    stem.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stemmablenote.html">
                    stemmablenote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stringnumber.html">
                    stringnumber.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="strokes.html">
                    strokes.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="svgcontext.html">
                    svgcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="system.html">
                    system.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tables.html">
                    tables.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabnote.html">
                    tabnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabslide.html">
                    tabslide.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabstave.html">
                    tabstave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tabtie.html">
                    tabtie.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textbracket.html">
                    textbracket.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textdynamics.html">
                    textdynamics.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="textnote.html">
                    textnote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickable.html">
                    tickable.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tickcontext.html">
                    tickcontext.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignature.html">
                    timesignature.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="timesignote.html">
                    timesignote.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tremolo.html">
                    tremolo.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuning.html">
                    tuning.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="tuplet.html">
                    tuplet.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vex.html">
                    vex.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vibrato.html">
                    vibrato.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="vibratobracket.html">
                    vibratobracket.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voice.html">
                    voice.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voicegroup.html">
                    voicegroup.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        <p><a href="http://vexflow.com">VexFlow</a> - Copyright (c) Mohit Muthanna 2010.</p>
<h2 id="description">Description</h2>
<p>This file implements notes for standard notation. This consists of one or
more <code>NoteHeads</code>, an optional stem, and an optional flag.</p>
<p><em>Throughout these comments, a “note” refers to the entire <code>StaveNote</code>,
and a “key” refers to a specific pitch/notehead within a note.</em></p>
<p>See <code>tests/stavenote_tests.js</code> for usage examples.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">import</span> { Vex } <span class="hljs-keyword">from</span> <span class="hljs-string">'./vex'</span>;
<span class="hljs-keyword">import</span> { Flow } <span class="hljs-keyword">from</span> <span class="hljs-string">'./tables'</span>;
<span class="hljs-keyword">import</span> { BoundingBox } <span class="hljs-keyword">from</span> <span class="hljs-string">'./boundingbox'</span>;
<span class="hljs-keyword">import</span> { Stem } <span class="hljs-keyword">from</span> <span class="hljs-string">'./stem'</span>;
<span class="hljs-keyword">import</span> { NoteHead } <span class="hljs-keyword">from</span> <span class="hljs-string">'./notehead'</span>;
<span class="hljs-keyword">import</span> { StemmableNote } <span class="hljs-keyword">from</span> <span class="hljs-string">'./stemmablenote'</span>;
<span class="hljs-keyword">import</span> { Modifier } <span class="hljs-keyword">from</span> <span class="hljs-string">'./modifier'</span>;
<span class="hljs-keyword">import</span> { Dot } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dot'</span>;</pre></div>
        
      
        
        <p>To enable logging for this class. Set <code>Vex.Flow.StaveNote.DEBUG</code> to <code>true</code>.</p>

        
          <div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">L</span>(<span class="hljs-params">...args</span>) </span>{ <span class="hljs-keyword">if</span> (StaveNote.DEBUG) Vex.L(<span class="hljs-string">'Vex.Flow.StaveNote'</span>, args); }

<span class="hljs-keyword">const</span> getStemAdjustment = (note) =&gt; Stem.WIDTH / (<span class="hljs-number">2</span> * -note.getStemDirection());

<span class="hljs-keyword">const</span> isInnerNoteIndex = (note, index) =&gt;
  index === (note.getStemDirection() === Stem.UP ? note.keyProps.length - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);</pre></div>
        
      
        
        <p>Helper methods for rest positioning in ModifierContext.</p>

        
          <div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shiftRestVertical</span>(<span class="hljs-params">rest, note, dir</span>) </span>{
  <span class="hljs-keyword">const</span> delta = (note.isrest ? <span class="hljs-number">0.0</span> : <span class="hljs-number">1.0</span>) * dir;

  rest.line += delta;
  rest.maxLine += delta;
  rest.minLine += delta;
  rest.note.setKeyLine(<span class="hljs-number">0</span>, rest.note.getKeyLine(<span class="hljs-number">0</span>) + (delta));
}</pre></div>
        
      
        
        <p>Called from formatNotes :: center a rest between two notes</p>

        
          <div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">centerRest</span>(<span class="hljs-params">rest, noteU, noteL</span>) </span>{
  <span class="hljs-keyword">const</span> delta = rest.line - Vex.MidLine(noteU.minLine, noteL.maxLine);
  rest.note.setKeyLine(<span class="hljs-number">0</span>, rest.note.getKeyLine(<span class="hljs-number">0</span>) - delta);
  rest.line -= delta;
  rest.maxLine -= delta;
  rest.minLine -= delta;
}

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaveNote</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StemmableNote</span> </span>{
  <span class="hljs-keyword">static</span> get CATEGORY() { <span class="hljs-keyword">return</span> <span class="hljs-string">'stavenotes'</span>; }
  <span class="hljs-keyword">static</span> get STEM_UP() { <span class="hljs-keyword">return</span> Stem.UP; }
  <span class="hljs-keyword">static</span> get STEM_DOWN() { <span class="hljs-keyword">return</span> Stem.DOWN; }
  <span class="hljs-keyword">static</span> get DEFAULT_LEDGER_LINE_OFFSET() { <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>; }</pre></div>
        
      
        
        <h2 id="static-methods">Static Methods</h2>
<p>Format notes inside a ModifierContext.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">static</span> format(notes, state) {
    <span class="hljs-keyword">if</span> (!notes || notes.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (notes[<span class="hljs-number">0</span>].getStave() != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> StaveNote.formatByY(notes, state);

    <span class="hljs-keyword">const</span> notesList = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; notes.length; i++) {
      <span class="hljs-keyword">const</span> props = notes[i].getKeyProps();
      <span class="hljs-keyword">const</span> line = props[<span class="hljs-number">0</span>].line;
      <span class="hljs-keyword">let</span> minL = props[props.length - <span class="hljs-number">1</span>].line;
      <span class="hljs-keyword">const</span> stemDirection = notes[i].getStemDirection();
      <span class="hljs-keyword">const</span> stemMax = notes[i].getStemLength() / <span class="hljs-number">10</span>;
      <span class="hljs-keyword">const</span> stemMin = notes[i].getStemMinumumLength() / <span class="hljs-number">10</span>;

      <span class="hljs-keyword">let</span> maxL;
      <span class="hljs-keyword">if</span> (notes[i].isRest()) {
        maxL = line + notes[i].glyph.line_above;
        minL = line - notes[i].glyph.line_below;
      } <span class="hljs-keyword">else</span> {
        maxL = stemDirection === <span class="hljs-number">1</span>
          ? props[props.length - <span class="hljs-number">1</span>].line + stemMax
          : props[props.length - <span class="hljs-number">1</span>].line;

        minL = stemDirection === <span class="hljs-number">1</span>
          ? props[<span class="hljs-number">0</span>].line
          : props[<span class="hljs-number">0</span>].line - stemMax;
      }

      notesList.push({
        line: props[<span class="hljs-number">0</span>].line, <span class="hljs-comment">// note/rest base line</span>
        maxLine: maxL, <span class="hljs-comment">// note/rest upper bounds line</span>
        minLine: minL, <span class="hljs-comment">// note/rest lower bounds line</span>
        isrest: notes[i].isRest(),
        stemDirection,
        stemMax, <span class="hljs-comment">// Maximum (default) note stem length;</span>
        stemMin, <span class="hljs-comment">// minimum note stem length</span>
        voice_shift: notes[i].getVoiceShiftWidth(),
        is_displaced: notes[i].isDisplaced(), <span class="hljs-comment">// note manually displaced</span>
        note: notes[i],
      });
    }

    <span class="hljs-keyword">const</span> voices = notesList.length;

    <span class="hljs-keyword">let</span> noteU = notesList[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> noteM = voices &gt; <span class="hljs-number">2</span> ? notesList[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> noteL = voices &gt; <span class="hljs-number">2</span> ? notesList[<span class="hljs-number">2</span>] : notesList[<span class="hljs-number">1</span>];</pre></div>
        
      
        
        <p>for two voice backward compatibility, ensure upper voice is stems up
for three voices, the voices must be in order (upper, middle, lower)</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (voices === <span class="hljs-number">2</span> &amp;&amp; noteU.stemDirection === <span class="hljs-number">-1</span> &amp;&amp; noteL.stemDirection === <span class="hljs-number">1</span>) {
      noteU = notesList[<span class="hljs-number">1</span>];
      noteL = notesList[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">const</span> voiceXShift = <span class="hljs-built_in">Math</span>.max(noteU.voice_shift, noteL.voice_shift);
    <span class="hljs-keyword">let</span> xShift = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> stemDelta;</pre></div>
        
      
        
        <p>Test for two voice note intersection</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (voices === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">const</span> lineSpacing = noteU.stemDirection === noteL.stemDirection ? <span class="hljs-number">0.0</span> : <span class="hljs-number">0.5</span>;</pre></div>
        
      
        
        <p>if top voice is a middle voice, check stem intersection with lower voice</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (noteU.stemDirection === noteL.stemDirection &amp;&amp;
          noteU.minLine &lt;= noteL.maxLine) {
        <span class="hljs-keyword">if</span> (!noteU.isrest) {
          stemDelta = <span class="hljs-built_in">Math</span>.abs(noteU.line - (noteL.maxLine + <span class="hljs-number">0.5</span>));
          stemDelta = <span class="hljs-built_in">Math</span>.max(stemDelta, noteU.stemMin);
          noteU.minLine = noteU.line - stemDelta;
          noteU.note.setStemLength(stemDelta * <span class="hljs-number">10</span>);
        }
      }
      <span class="hljs-keyword">if</span> (noteU.minLine &lt;= noteL.maxLine + lineSpacing) {
        <span class="hljs-keyword">if</span> (noteU.isrest) {</pre></div>
        
      
        
        <p>shift rest up</p>

        
          <div class='highlight'><pre>          shiftRestVertical(noteU, noteL, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (noteL.isrest) {</pre></div>
        
      
        
        <p>shift rest down</p>

        
          <div class='highlight'><pre>          shiftRestVertical(noteL, noteU, <span class="hljs-number">-1</span>);
        } <span class="hljs-keyword">else</span> {
          xShift = voiceXShift;
          <span class="hljs-keyword">if</span> (noteU.stemDirection === noteL.stemDirection) {</pre></div>
        
      
        
        <p>upper voice is middle voice, so shift it right</p>

        
          <div class='highlight'><pre>            noteU.note.setXShift(xShift + <span class="hljs-number">3</span>);
          } <span class="hljs-keyword">else</span> {</pre></div>
        
      
        
        <p>shift lower voice right</p>

        
          <div class='highlight'><pre>            noteL.note.setXShift(xShift);
          }
        }
      }</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div>
        
      
        
        <p>Check middle voice stem intersection with lower voice</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM !== <span class="hljs-literal">null</span> &amp;&amp; noteM.minLine &lt; noteL.maxLine + <span class="hljs-number">0.5</span>) {
      <span class="hljs-keyword">if</span> (!noteM.isrest) {
        stemDelta = <span class="hljs-built_in">Math</span>.abs(noteM.line - (noteL.maxLine + <span class="hljs-number">0.5</span>));
        stemDelta = <span class="hljs-built_in">Math</span>.max(stemDelta, noteM.stemMin);
        noteM.minLine = noteM.line - stemDelta;
        noteM.note.setStemLength(stemDelta * <span class="hljs-number">10</span>);
      }
    }</pre></div>
        
      
        
        <p>For three voices, test if rests can be repositioned</p>
<p>Special case 1 :: middle voice rest between two notes</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; !noteU.isrest &amp;&amp; !noteL.isrest) {
      <span class="hljs-keyword">if</span> (noteU.minLine &lt;= noteM.maxLine || noteM.minLine &lt;= noteL.maxLine) {
        <span class="hljs-keyword">const</span> restHeight = noteM.maxLine - noteM.minLine;
        <span class="hljs-keyword">const</span> space = noteU.minLine - noteL.maxLine;
        <span class="hljs-keyword">if</span> (restHeight &lt; space) {</pre></div>
        
      
        
        <p>center middle voice rest between the upper and lower voices</p>

        
          <div class='highlight'><pre>          centerRest(noteM, noteU, noteL);
        } <span class="hljs-keyword">else</span> {
          xShift = voiceXShift + <span class="hljs-number">3</span>;    <span class="hljs-comment">// shift middle rest right</span>
          noteM.note.setXShift(xShift);
        }</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }</pre></div>
        
      
        
        <p>Special case 2 :: all voices are rests</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteU.isrest &amp;&amp; noteM.isrest &amp;&amp; noteL.isrest) {</pre></div>
        
      
        
        <p>Shift upper voice rest up</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteU, noteM, <span class="hljs-number">1</span>);</pre></div>
        
      
        
        <p>Shift lower voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteL, noteM, <span class="hljs-number">-1</span>);</pre></div>
        
      
        
        <p>format complete</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div>
        
      
        
        <p>Test if any other rests can be repositioned</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; noteU.isrest &amp;&amp; noteM.minLine &lt;= noteL.maxLine) {</pre></div>
        
      
        
        <p>Shift middle voice rest up</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteM, noteL, <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">if</span> (noteM.isrest &amp;&amp; noteL.isrest &amp;&amp; noteU.minLine &lt;= noteM.maxLine) {</pre></div>
        
      
        
        <p>Shift middle voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteM, noteU, <span class="hljs-number">-1</span>);
    }
    <span class="hljs-keyword">if</span> (noteU.isrest &amp;&amp; noteU.minLine &lt;= noteM.maxLine) {</pre></div>
        
      
        
        <p>shift upper voice rest up;</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteU, noteM, <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">if</span> (noteL.isrest &amp;&amp; noteM.minLine &lt;= noteL.maxLine) {</pre></div>
        
      
        
        <p>shift lower voice rest down</p>

        
          <div class='highlight'><pre>      shiftRestVertical(noteL, noteM, <span class="hljs-number">-1</span>);
    }</pre></div>
        
      
        
        <p>If middle voice intersects upper or lower voice</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> ((!noteU.isrest &amp;&amp; !noteM.isrest &amp;&amp; noteU.minLine &lt;= noteM.maxLine + <span class="hljs-number">0.5</span>) ||
        (!noteM.isrest &amp;&amp; !noteL.isrest &amp;&amp; noteM.minLine &lt;= noteL.maxLine)) {
      xShift = voiceXShift + <span class="hljs-number">3</span>;      <span class="hljs-comment">// shift middle note right</span>
      noteM.note.setXShift(xShift);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">static</span> formatByY(notes, state) {</pre></div>
        
      
        
        <p>NOTE: this function does not support more than two voices per stave
use with care.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">let</span> hasStave = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; notes.length; i++) {
      hasStave = hasStave &amp;&amp; notes[i].getStave() != <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (!hasStave) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(
        <span class="hljs-string">'Stave Missing'</span>,
        <span class="hljs-string">'All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!'</span>
      );
    }

    <span class="hljs-keyword">let</span> xShift = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; notes.length - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-keyword">let</span> topNote = notes[i];
      <span class="hljs-keyword">let</span> bottomNote = notes[i + <span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (topNote.getStemDirection() === Stem.DOWN) {
        topNote = notes[i + <span class="hljs-number">1</span>];
        bottomNote = notes[i];
      }

      <span class="hljs-keyword">const</span> topKeys = topNote.getKeyProps();
      <span class="hljs-keyword">const</span> bottomKeys = bottomNote.getKeyProps();

      <span class="hljs-keyword">const</span> HALF_NOTEHEAD_HEIGHT = <span class="hljs-number">0.5</span>;</pre></div>
        
      
        
        <p><code>keyProps</code> and <code>stave.getYForLine</code> have different notions of a <code>line</code>
so we have to convert the keyProps value by subtracting 5.
See <a href="https://github.com/0xfe/vexflow/wiki/Development-Gotchas">https://github.com/0xfe/vexflow/wiki/Development-Gotchas</a></p>
<p>We also extend the y for each note by a half notehead because the
notehead’s origin is centered</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">const</span> topNotBottomY = topNote
        .getStave()
        .getYForLine(<span class="hljs-number">5</span> - topKeys[<span class="hljs-number">0</span>].line + HALF_NOTEHEAD_HEIGHT);

      <span class="hljs-keyword">const</span> bottomNoteTopY = bottomNote
        .getStave()
        .getYForLine(<span class="hljs-number">5</span> - bottomKeys[bottomKeys.length - <span class="hljs-number">1</span>].line - HALF_NOTEHEAD_HEIGHT);

      <span class="hljs-keyword">const</span> areNotesColliding = bottomNoteTopY - topNotBottomY &lt; <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (areNotesColliding) {
        xShift = topNote.getVoiceShiftWidth();
        bottomNote.setXShift(xShift);
      }
    }

    state.right_shift += xShift;
  }

  <span class="hljs-keyword">static</span> postFormat(notes) {
    <span class="hljs-keyword">if</span> (!notes) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    notes.forEach(note =&gt; note.postFormat());

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">constructor</span>(noteStruct) {
    <span class="hljs-keyword">super</span>(noteStruct);
    <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">'type'</span>, <span class="hljs-string">'StaveNote'</span>);

    <span class="hljs-keyword">this</span>.keys = noteStruct.keys;
    <span class="hljs-keyword">this</span>.clef = noteStruct.clef;
    <span class="hljs-keyword">this</span>.octave_shift = noteStruct.octave_shift;
    <span class="hljs-keyword">this</span>.beam = <span class="hljs-literal">null</span>;</pre></div>
        
      
        
        <p>Pull note rendering properties</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.glyph = Flow.durationToGlyph(<span class="hljs-keyword">this</span>.duration, <span class="hljs-keyword">this</span>.noteType);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.glyph) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(
        <span class="hljs-string">'BadArguments'</span>,
        <span class="hljs-string">`Invalid note initialization data (No glyph found): <span class="hljs-subst">${JSON.stringify(noteStruct)}</span>`</span>
      );
    }</pre></div>
        
      
        
        <p>if true, displace note to right</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.displaced = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.dot_shiftY = <span class="hljs-number">0</span>;</pre></div>
        
      
        
        <p>per-pitch properties</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.keyProps = [];</pre></div>
        
      
        
        <p>for displaced ledger lines</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.use_default_head_x = <span class="hljs-literal">false</span>;</pre></div>
        
      
        
        <p>Drawing</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.note_heads = [];
    <span class="hljs-keyword">this</span>.modifiers = [];

    Vex.Merge(<span class="hljs-keyword">this</span>.render_options, {</pre></div>
        
      
        
        <p>font size for note heads and rests</p>

        
          <div class='highlight'><pre>      glyph_font_scale: noteStruct.glyph_font_scale || Flow.DEFAULT_NOTATION_FONT_SCALE,</pre></div>
        
      
        
        <p>number of stroke px to the left and right of head</p>

        
          <div class='highlight'><pre>      stroke_px: noteStruct.stroke_px || StaveNote.DEFAULT_LEDGER_LINE_OFFSET,
    });

    <span class="hljs-keyword">this</span>.calculateKeyProps();
    <span class="hljs-keyword">this</span>.buildStem();</pre></div>
        
      
        
        <p>Set the stem direction</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (noteStruct.auto_stem) {
      <span class="hljs-keyword">this</span>.autoStem();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.setStemDirection(noteStruct.stem_direction);
    }
    <span class="hljs-keyword">this</span>.reset();
    <span class="hljs-keyword">this</span>.buildFlag();
    <span class="hljs-keyword">this</span>.calcExtraPx();
  }

  reset() {
    <span class="hljs-keyword">super</span>.reset();
    <span class="hljs-keyword">this</span>.buildNoteHeads();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stave) {
      <span class="hljs-keyword">this</span>.note_heads.forEach(head =&gt; head.setStave(<span class="hljs-keyword">this</span>.stave));
    }
  }

  getCategory() { <span class="hljs-keyword">return</span> StaveNote.CATEGORY; }</pre></div>
        
      
        
        <p>Builds a <code>Stem</code> for the note</p>

        
          <div class='highlight'><pre>  buildStem() {
    <span class="hljs-keyword">const</span> glyph = <span class="hljs-keyword">this</span>.getGlyph();
    <span class="hljs-keyword">const</span> yExtend = glyph.code_head === <span class="hljs-string">'v95'</span> || glyph.code_head === <span class="hljs-string">'v3e'</span> ? <span class="hljs-number">-4</span> : <span class="hljs-number">0</span>;

    <span class="hljs-keyword">this</span>.setStem(<span class="hljs-keyword">new</span> Stem({
      yExtend,
      hide: !!<span class="hljs-keyword">this</span>.isRest(),
    }));
  }</pre></div>
        
      
        
        <p>Builds a <code>NoteHead</code> for each key in the note</p>

        
          <div class='highlight'><pre>  buildNoteHeads() {
    <span class="hljs-keyword">this</span>.note_heads = [];
    <span class="hljs-keyword">const</span> stemDirection = <span class="hljs-keyword">this</span>.getStemDirection();
    <span class="hljs-keyword">const</span> keys = <span class="hljs-keyword">this</span>.getKeys();

    <span class="hljs-keyword">let</span> lastLine = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> lineDiff = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> displaced = <span class="hljs-literal">false</span>;</pre></div>
        
      
        
        <p>Draw notes from bottom to top.</p>

        
      
        
        <p>For down-stem notes, we draw from top to bottom.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">let</span> start;
    <span class="hljs-keyword">let</span> end;
    <span class="hljs-keyword">let</span> step;
    <span class="hljs-keyword">if</span> (stemDirection === Stem.UP) {
      start = <span class="hljs-number">0</span>;
      end = keys.length;
      step = <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stemDirection === Stem.DOWN) {
      start = keys.length - <span class="hljs-number">1</span>;
      end = <span class="hljs-number">-1</span>;
      step = <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i !== end; i += step) {
      <span class="hljs-keyword">const</span> noteProps = <span class="hljs-keyword">this</span>.keyProps[i];
      <span class="hljs-keyword">const</span> line = noteProps.line;</pre></div>
        
      
        
        <p>Keep track of last line with a note head, so that consecutive heads
are correctly displaced.</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (lastLine === <span class="hljs-literal">null</span>) {
        lastLine = line;
      } <span class="hljs-keyword">else</span> {
        lineDiff = <span class="hljs-built_in">Math</span>.abs(lastLine - line);
        <span class="hljs-keyword">if</span> (lineDiff === <span class="hljs-number">0</span> || lineDiff === <span class="hljs-number">0.5</span>) {
          displaced = !displaced;
        } <span class="hljs-keyword">else</span> {
          displaced = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">this</span>.use_default_head_x = <span class="hljs-literal">true</span>;
        }
      }
      lastLine = line;

      <span class="hljs-keyword">const</span> notehead = <span class="hljs-keyword">new</span> NoteHead({
        duration: <span class="hljs-keyword">this</span>.duration,
        note_type: <span class="hljs-keyword">this</span>.noteType,
        displaced,
        stem_direction: stemDirection,
        custom_glyph_code: noteProps.code,
        glyph_font_scale: <span class="hljs-keyword">this</span>.render_options.glyph_font_scale,
        x_shift: noteProps.shift_right,
        line: noteProps.line,
      });

      <span class="hljs-keyword">this</span>.note_heads[i] = notehead;
    }
  }</pre></div>
        
      
        
        <p>Automatically sets the stem direction based on the keys in the note</p>

        
          <div class='highlight'><pre>  autoStem() {</pre></div>
        
      
        
        <p>Figure out optimal stem direction based on given notes</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.minLine = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;
    <span class="hljs-keyword">this</span>.maxLine = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-keyword">this</span>.keyProps.length - <span class="hljs-number">1</span>].line;

    <span class="hljs-keyword">const</span> MIDDLE_LINE = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> decider = (<span class="hljs-keyword">this</span>.minLine + <span class="hljs-keyword">this</span>.maxLine) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">const</span> stemDirection = decider &lt; MIDDLE_LINE ? Stem.UP : Stem.DOWN;

    <span class="hljs-keyword">this</span>.setStemDirection(stemDirection);
  }</pre></div>
        
      
        
        <p>Calculates and stores the properties for each key in the note</p>

        
          <div class='highlight'><pre>  calculateKeyProps() {
    <span class="hljs-keyword">let</span> lastLine = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.keys.length; ++i) {
      <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">this</span>.keys[i];</pre></div>
        
      
        
        <p>All rests use the same position on the line.
if (this.glyph.rest) key = this.glyph.position;</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.rest) <span class="hljs-keyword">this</span>.glyph.position = key;

      <span class="hljs-keyword">const</span> options = { octave_shift: <span class="hljs-keyword">this</span>.octave_shift || <span class="hljs-number">0</span> };
      <span class="hljs-keyword">const</span> props = Flow.keyProperties(key, <span class="hljs-keyword">this</span>.clef, options);

      <span class="hljs-keyword">if</span> (!props) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RuntimeError(<span class="hljs-string">'BadArguments'</span>, <span class="hljs-string">`Invalid key for note properties: <span class="hljs-subst">${key}</span>`</span>);
      }</pre></div>
        
      
        
        <p>Override line placement for default rests</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">if</span> (props.key === <span class="hljs-string">'R'</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.duration === <span class="hljs-string">'1'</span> || <span class="hljs-keyword">this</span>.duration === <span class="hljs-string">'w'</span>) {
          props.line = <span class="hljs-number">4</span>;
        } <span class="hljs-keyword">else</span> {
          props.line = <span class="hljs-number">3</span>;
        }
      }</pre></div>
        
      
        
        <p>Calculate displacement of this note</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">const</span> line = props.line;
      <span class="hljs-keyword">if</span> (lastLine === <span class="hljs-literal">null</span>) {
        lastLine = line;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(lastLine - line) === <span class="hljs-number">0.5</span>) {
          <span class="hljs-keyword">this</span>.displaced = <span class="hljs-literal">true</span>;
          props.displaced = <span class="hljs-literal">true</span>;</pre></div>
        
      
        
        <p>Have to mark the previous note as
displaced as well, for modifier placement</p>

        
          <div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keyProps.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.keyProps[i - <span class="hljs-number">1</span>].displaced = <span class="hljs-literal">true</span>;
          }
        }
      }

      lastLine = line;
      <span class="hljs-keyword">this</span>.keyProps.push(props);
    }</pre></div>
        
      
        
        <p>Sort the notes from lowest line to highest line</p>

        
          <div class='highlight'><pre>    lastLine = -<span class="hljs-literal">Infinity</span>;
    <span class="hljs-keyword">this</span>.keyProps.forEach(key =&gt; {
      <span class="hljs-keyword">if</span> (key.line &lt; lastLine) {
        Vex.W(
          <span class="hljs-string">'Unsorted keys in note will be sorted. '</span> +
          <span class="hljs-string">'See https://github.com/0xfe/vexflow/issues/104 for details.'</span>
        );
      }
      lastLine = key.line;
    });
    <span class="hljs-keyword">this</span>.keyProps.sort((a, b) =&gt; a.line - b.line);
  }</pre></div>
        
      
        
        <p>Get the <code>BoundingBox</code> for the entire note</p>

        
          <div class='highlight'><pre>  getBoundingBox() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.preFormatted) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'UnformattedNote'</span>, <span class="hljs-string">"Can't call getBoundingBox on an unformatted note."</span>);
    }

    <span class="hljs-keyword">const</span> { width: w, modLeftPx, extraLeftPx } = <span class="hljs-keyword">this</span>.getMetrics();
    <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">this</span>.getAbsoluteX() - modLeftPx - extraLeftPx;

    <span class="hljs-keyword">let</span> minY = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> maxY = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> halfLineSpacing = <span class="hljs-keyword">this</span>.getStave().getSpacingBetweenLines() / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">const</span> lineSpacing = halfLineSpacing * <span class="hljs-number">2</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRest()) {
      <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">this</span>.ys[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">const</span> frac = Flow.durationToFraction(<span class="hljs-keyword">this</span>.duration);
      <span class="hljs-keyword">if</span> (frac.equals(<span class="hljs-number">1</span>) || frac.equals(<span class="hljs-number">2</span>)) {
        minY = y - halfLineSpacing;
        maxY = y + halfLineSpacing;
      } <span class="hljs-keyword">else</span> {
        minY = y - (<span class="hljs-keyword">this</span>.glyph.line_above * lineSpacing);
        maxY = y + (<span class="hljs-keyword">this</span>.glyph.line_below * lineSpacing);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.stem) {
      <span class="hljs-keyword">const</span> ys = <span class="hljs-keyword">this</span>.getStemExtents();
      ys.baseY += halfLineSpacing * <span class="hljs-keyword">this</span>.stem_direction;
      minY = <span class="hljs-built_in">Math</span>.min(ys.topY, ys.baseY);
      maxY = <span class="hljs-built_in">Math</span>.max(ys.topY, ys.baseY);
    } <span class="hljs-keyword">else</span> {
      minY = <span class="hljs-literal">null</span>;
      maxY = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.ys.length; ++i) {
        <span class="hljs-keyword">const</span> yy = <span class="hljs-keyword">this</span>.ys[i];
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
          minY = yy;
          maxY = yy;
        } <span class="hljs-keyword">else</span> {
          minY = <span class="hljs-built_in">Math</span>.min(yy, minY);
          maxY = <span class="hljs-built_in">Math</span>.max(yy, maxY);
        }
      }
      minY -= halfLineSpacing;
      maxY += halfLineSpacing;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BoundingBox(x, minY, w, maxY - minY);
  }</pre></div>
        
      
        
        <p>Gets the line number of the top or bottom note in the chord.
If <code>isTopNote</code> is <code>true</code> then get the top note</p>

        
          <div class='highlight'><pre>  getLineNumber(isTopNote) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.keyProps.length) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(
        <span class="hljs-string">'NoKeyProps'</span>, <span class="hljs-string">"Can't get bottom note line, because note is not initialized properly."</span>
      );
    }

    <span class="hljs-keyword">let</span> resultLine = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;</pre></div>
        
      
        
        <p>No precondition assumed for sortedness of keyProps array</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.keyProps.length; i++) {
      <span class="hljs-keyword">const</span> thisLine = <span class="hljs-keyword">this</span>.keyProps[i].line;
      <span class="hljs-keyword">if</span> (isTopNote) {
        <span class="hljs-keyword">if</span> (thisLine &gt; resultLine) resultLine = thisLine;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (thisLine &lt; resultLine) resultLine = thisLine;
      }
    }

    <span class="hljs-keyword">return</span> resultLine;
  }</pre></div>
        
      
        
        <p>Determine if current note is a rest</p>

        
          <div class='highlight'><pre>  isRest() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.glyph.rest; }</pre></div>
        
      
        
        <p>Determine if the current note is a chord</p>

        
          <div class='highlight'><pre>  isChord() { <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isRest() &amp;&amp; <span class="hljs-keyword">this</span>.keys.length &gt; <span class="hljs-number">1</span>; }</pre></div>
        
      
        
        <p>Determine if the <code>StaveNote</code> has a stem</p>

        
          <div class='highlight'><pre>  hasStem() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.glyph.stem; }

  hasFlag() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.hasFlag() &amp;&amp; !<span class="hljs-keyword">this</span>.isRest();
  }

  getStemX() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.noteType === <span class="hljs-string">'r'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getCenterGlyphX();
    } <span class="hljs-keyword">else</span> {</pre></div>
        
      
        
        <p>We adjust the origin of the stem because we want the stem left-aligned
with the notehead if stemmed-down, and right-aligned if stemmed-up</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getStemX() + getStemAdjustment(<span class="hljs-keyword">this</span>);
    }
  }</pre></div>
        
      
        
        <p>Get the <code>y</code> coordinate for text placed on the top/bottom of a
note at a desired <code>text_line</code></p>

        
          <div class='highlight'><pre>  getYForTopText(textLine) {
    <span class="hljs-keyword">const</span> extents = <span class="hljs-keyword">this</span>.getStemExtents();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(
      <span class="hljs-keyword">this</span>.stave.getYForTopText(textLine),
      extents.topY - (<span class="hljs-keyword">this</span>.render_options.annotation_spacing * (textLine + <span class="hljs-number">1</span>))
    );
  }
  getYForBottomText(textLine) {
    <span class="hljs-keyword">const</span> extents = <span class="hljs-keyword">this</span>.getStemExtents();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(
      <span class="hljs-keyword">this</span>.stave.getYForTopText(textLine),
      extents.baseY + (<span class="hljs-keyword">this</span>.render_options.annotation_spacing * (textLine))
    );
  }</pre></div>
        
      
        
        <p>Sets the current note to the provided <code>stave</code>. This applies
<code>y</code> values to the <code>NoteHeads</code>.</p>

        
          <div class='highlight'><pre>  setStave(stave) {
    <span class="hljs-keyword">super</span>.setStave(stave);

    <span class="hljs-keyword">const</span> ys = <span class="hljs-keyword">this</span>.note_heads.map(notehead =&gt; {
      notehead.setStave(stave);
      <span class="hljs-keyword">return</span> notehead.getY();
    });

    <span class="hljs-keyword">this</span>.setYs(ys);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stem) {
      <span class="hljs-keyword">const</span> { y_top, y_bottom } = <span class="hljs-keyword">this</span>.getNoteHeadBounds();
      <span class="hljs-keyword">this</span>.stem.setYBounds(y_top, y_bottom);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div>
        
      
        
        <p>Get the pitches in the note</p>

        
          <div class='highlight'><pre>  getKeys() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keys; }</pre></div>
        
      
        
        <p>Get the properties for all the keys in the note</p>

        
          <div class='highlight'><pre>  getKeyProps() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keyProps;
  }</pre></div>
        
      
        
        <p>Check if note is shifted to the right</p>

        
          <div class='highlight'><pre>  isDisplaced() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.displaced;
  }</pre></div>
        
      
        
        <p>Sets whether shift note to the right. <code>displaced</code> is a <code>boolean</code></p>

        
          <div class='highlight'><pre>  setNoteDisplaced(displaced) {
    <span class="hljs-keyword">this</span>.displaced = displaced;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div>
        
      
        
        <p>Get the starting <code>x</code> coordinate for a <code>StaveTie</code></p>

        
          <div class='highlight'><pre>  getTieRightX() {
    <span class="hljs-keyword">let</span> tieStartX = <span class="hljs-keyword">this</span>.getAbsoluteX();
    tieStartX += <span class="hljs-keyword">this</span>.getGlyphWidth() + <span class="hljs-keyword">this</span>.x_shift + <span class="hljs-keyword">this</span>.extraRightPx;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.modifierContext) tieStartX += <span class="hljs-keyword">this</span>.modifierContext.getExtraRightPx();
    <span class="hljs-keyword">return</span> tieStartX;
  }</pre></div>
        
      
        
        <p>Get the ending <code>x</code> coordinate for a <code>StaveTie</code></p>

        
          <div class='highlight'><pre>  getTieLeftX() {
    <span class="hljs-keyword">let</span> tieEndX = <span class="hljs-keyword">this</span>.getAbsoluteX();
    tieEndX += <span class="hljs-keyword">this</span>.x_shift - <span class="hljs-keyword">this</span>.extraLeftPx;
    <span class="hljs-keyword">return</span> tieEndX;
  }</pre></div>
        
      
        
        <p>Get the stave line on which to place a rest</p>

        
          <div class='highlight'><pre>  getLineForRest() {
    <span class="hljs-keyword">let</span> restLine = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-number">0</span>].line;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keyProps.length &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> lastLine  = <span class="hljs-keyword">this</span>.keyProps[<span class="hljs-keyword">this</span>.keyProps.length - <span class="hljs-number">1</span>].line;
      <span class="hljs-keyword">const</span> top = <span class="hljs-built_in">Math</span>.max(restLine, lastLine);
      <span class="hljs-keyword">const</span> bot = <span class="hljs-built_in">Math</span>.min(restLine, lastLine);
      restLine = Vex.MidLine(top, bot);
    }

    <span class="hljs-keyword">return</span> restLine;
  }</pre></div>
        
      
        
        <p>Get the default <code>x</code> and <code>y</code> coordinates for the provided <code>position</code>
and key <code>index</code></p>

        
          <div class='highlight'><pre>  getModifierStartXY(position, index) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.preFormatted) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'UnformattedNote'</span>, <span class="hljs-string">"Can't call GetModifierStartXY on an unformatted note"</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ys.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoYValues'</span>, <span class="hljs-string">'No Y-Values calculated for this note.'</span>);
    }

    <span class="hljs-keyword">const</span> { ABOVE, BELOW, LEFT, RIGHT } = Modifier.Position;
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (position === LEFT) {</pre></div>
        
      
        
        <p>extra_left_px
FIXME: What are these magic numbers?</p>

        
          <div class='highlight'><pre>      x = <span class="hljs-number">-1</span> * <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === RIGHT) {</pre></div>
        
      
        
        <p>extra_right_px
FIXME: What is this magical +2?</p>

        
          <div class='highlight'><pre>      x = <span class="hljs-keyword">this</span>.getGlyphWidth() + <span class="hljs-keyword">this</span>.x_shift + <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stem_direction === Stem.UP &amp;&amp; <span class="hljs-keyword">this</span>.hasFlag() &amp;&amp; isInnerNoteIndex(<span class="hljs-keyword">this</span>, index)) {
        x += <span class="hljs-keyword">this</span>.flag.getMetrics().width;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === BELOW || position === ABOVE) {
      x = <span class="hljs-keyword">this</span>.getGlyphWidth() / <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">return</span> {
      x: <span class="hljs-keyword">this</span>.getAbsoluteX() + x,
      y: <span class="hljs-keyword">this</span>.ys[index],
    };
  }</pre></div>
        
      
        
        <p>Sets the style of the complete StaveNote, including all keys
and the stem.</p>

        
          <div class='highlight'><pre>  setStyle(style) {
    <span class="hljs-keyword">this</span>.note_heads.forEach(notehead =&gt; notehead.setStyle(style));
    <span class="hljs-keyword">this</span>.stem.setStyle(style);
  }</pre></div>
        
      
        
        <p>Sets the notehead at <code>index</code> to the provided coloring <code>style</code>.</p>
<p><code>style</code> is an <code>object</code> with the following properties: <code>shadowColor</code>,
<code>shadowBlur</code>, <code>fillStyle</code>, <code>strokeStyle</code></p>

        
          <div class='highlight'><pre>  setKeyStyle(index, style) {
    <span class="hljs-keyword">this</span>.note_heads[index].setStyle(style);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  setKeyLine(index, line) {
    <span class="hljs-keyword">this</span>.keyProps[index].line = line;
    <span class="hljs-keyword">this</span>.note_heads[index].setLine(line);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  getKeyLine(index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keyProps[index].line;
  }</pre></div>
        
      
        
        <p>Add self to modifier context. <code>mContext</code> is the <code>ModifierContext</code>
to be added to.</p>

        
          <div class='highlight'><pre>  addToModifierContext(mContext) {
    <span class="hljs-keyword">this</span>.setModifierContext(mContext);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.modifiers.length; ++i) {
      <span class="hljs-keyword">this</span>.modifierContext.addModifier(<span class="hljs-keyword">this</span>.modifiers[i]);
    }
    <span class="hljs-keyword">this</span>.modifierContext.addModifier(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div>
        
      
        
        <p>Generic function to add modifiers to a note</p>
<p>Parameters:</p>
<ul>
<li><code>index</code>: The index of the key that we’re modifying</li>
<li><code>modifier</code>: The modifier to add</li>
</ul>

        
          <div class='highlight'><pre>  addModifier(index, modifier) {
    modifier.setNote(<span class="hljs-keyword">this</span>);
    modifier.setIndex(index);
    <span class="hljs-keyword">this</span>.modifiers.push(modifier);
    <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div>
        
      
        
        <p>Helper function to add an accidental to a key</p>

        
          <div class='highlight'><pre>  addAccidental(index, accidental) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, accidental);
  }</pre></div>
        
      
        
        <p>Helper function to add an articulation to a key</p>

        
          <div class='highlight'><pre>  addArticulation(index, articulation) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, articulation);
  }</pre></div>
        
      
        
        <p>Helper function to add an annotation to a key</p>

        
          <div class='highlight'><pre>  addAnnotation(index, annotation) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, annotation);
  }</pre></div>
        
      
        
        <p>Helper function to add a dot on a specific key</p>

        
          <div class='highlight'><pre>  addDot(index) {
    <span class="hljs-keyword">const</span> dot = <span class="hljs-keyword">new</span> Dot();
    dot.setDotShiftY(<span class="hljs-keyword">this</span>.glyph.dot_shiftY);
    <span class="hljs-keyword">this</span>.dots++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addModifier(index, dot);
  }</pre></div>
        
      
        
        <p>Convenience method to add dot to all keys in note</p>

        
          <div class='highlight'><pre>  addDotToAll() {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.keys.length; ++i) {
      <span class="hljs-keyword">this</span>.addDot(i);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div>
        
      
        
        <p>Get all accidentals in the <code>ModifierContext</code></p>

        
          <div class='highlight'><pre>  getAccidentals() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modifierContext.getModifiers(<span class="hljs-string">'accidentals'</span>);
  }</pre></div>
        
      
        
        <p>Get all dots in the <code>ModifierContext</code></p>

        
          <div class='highlight'><pre>  getDots() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modifierContext.getModifiers(<span class="hljs-string">'dots'</span>);
  }</pre></div>
        
      
        
        <p>Get the width of the note if it is displaced. Used for <code>Voice</code>
formatting</p>

        
          <div class='highlight'><pre>  getVoiceShiftWidth() {</pre></div>
        
      
        
        <p>TODO: may need to accomodate for dot here.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getGlyphWidth() * (<span class="hljs-keyword">this</span>.displaced ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);
  }</pre></div>
        
      
        
        <p>Calculates and sets the extra pixels to the left or right
if the note is displaced.</p>

        
          <div class='highlight'><pre>  calcExtraPx() {
    <span class="hljs-keyword">this</span>.setExtraLeftPx(
      <span class="hljs-keyword">this</span>.displaced &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction === Stem.DOWN
        ? <span class="hljs-keyword">this</span>.getGlyphWidth()
        : <span class="hljs-number">0</span>
    );</pre></div>
        
      
        
        <p>For upstems with flags, the extra space is unnecessary, since it’s taken
up by the flag.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.setExtraRightPx(
      !<span class="hljs-keyword">this</span>.hasFlag() &amp;&amp; <span class="hljs-keyword">this</span>.displaced &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction === Stem.UP
        ? <span class="hljs-keyword">this</span>.getGlyphWidth()
        : <span class="hljs-number">0</span>
    );
  }</pre></div>
        
      
        
        <p>Pre-render formatting</p>

        
          <div class='highlight'><pre>  preFormat() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preFormatted) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.modifierContext) <span class="hljs-keyword">this</span>.modifierContext.preFormat();

    <span class="hljs-keyword">let</span> width = <span class="hljs-keyword">this</span>.getGlyphWidth() + <span class="hljs-keyword">this</span>.extraLeftPx + <span class="hljs-keyword">this</span>.extraRightPx;</pre></div>
        
      
        
        <p>For upward flagged notes, the width of the flag needs to be added</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.glyph.flag &amp;&amp; <span class="hljs-keyword">this</span>.beam === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.stem_direction === Stem.UP) {
      width += <span class="hljs-keyword">this</span>.getGlyphWidth();
    }

    <span class="hljs-keyword">this</span>.setWidth(width);
    <span class="hljs-keyword">this</span>.setPreFormatted(<span class="hljs-literal">true</span>);
  }</pre></div>
        
      
        
        <p>Gets the staff line and y value for the highest and lowest noteheads</p>

        
          <div class='highlight'><pre>  getNoteHeadBounds() {</pre></div>
        
      
        
        <p>Top and bottom Y values for stem.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">let</span> yTop = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> yBottom = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> highestLine = <span class="hljs-keyword">this</span>.stave.getNumLines();
    <span class="hljs-keyword">let</span> lowestLine = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">this</span>.note_heads.forEach(notehead =&gt; {
      <span class="hljs-keyword">const</span> line = notehead.getLine();
      <span class="hljs-keyword">const</span> y = notehead.getY();

      <span class="hljs-keyword">if</span> (yTop === <span class="hljs-literal">null</span> || y &lt; yTop)  {
        yTop = y;
      }

      <span class="hljs-keyword">if</span> (yBottom === <span class="hljs-literal">null</span> || y &gt; yBottom) {
        yBottom = y;
      }

      highestLine = line &gt; highestLine ? line : highestLine;
      lowestLine = line &lt; lowestLine ? line : lowestLine;
    }, <span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">return</span> {
      y_top: yTop,
      y_bottom: yBottom,
      highest_line: highestLine,
      lowest_line: lowestLine,
    };
  }</pre></div>
        
      
        
        <p>Get the starting <code>x</code> coordinate for the noteheads</p>

        
          <div class='highlight'><pre>  getNoteHeadBeginX() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAbsoluteX() + <span class="hljs-keyword">this</span>.x_shift;
  }</pre></div>
        
      
        
        <p>Get the ending <code>x</code> coordinate for the noteheads</p>

        
          <div class='highlight'><pre>  getNoteHeadEndX() {
    <span class="hljs-keyword">const</span> xBegin = <span class="hljs-keyword">this</span>.getNoteHeadBeginX();
    <span class="hljs-keyword">return</span> xBegin + <span class="hljs-keyword">this</span>.getGlyphWidth();
  }</pre></div>
        
      
        
        <p>Draw the ledger lines between the stave and the highest/lowest keys</p>

        
          <div class='highlight'><pre>  drawLedgerLines() {
    <span class="hljs-keyword">const</span> {
      note_heads, stave, use_default_head_x, x_shift, glyph,
      render_options: { stroke_px },
      context: ctx,
    } = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRest()) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!ctx) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoCanvasContext'</span>, <span class="hljs-string">"Can't draw without a canvas context."</span>);
    }

    <span class="hljs-keyword">const</span> { highest_line, lowest_line } = <span class="hljs-keyword">this</span>.getNoteHeadBounds();
    <span class="hljs-keyword">let</span> headX = note_heads[<span class="hljs-number">0</span>].getAbsoluteX();

    <span class="hljs-keyword">const</span> drawLedgerLine = (y) =&gt; {
      <span class="hljs-keyword">if</span> (use_default_head_x === <span class="hljs-literal">true</span>)  {
        headX = <span class="hljs-keyword">this</span>.getAbsoluteX() + x_shift;
      }
      <span class="hljs-keyword">const</span> x = headX - stroke_px;
      <span class="hljs-keyword">const</span> length = ((headX + glyph.getWidth()) - headX) + (stroke_px * <span class="hljs-number">2</span>);

      ctx.fillRect(x, y, length, <span class="hljs-number">1</span>);
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> line = <span class="hljs-number">6</span>; line &lt;= highest_line; ++line) {
      drawLedgerLine(stave.getYForNote(line));
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> line = <span class="hljs-number">0</span>; line &gt;= lowest_line; --line) {
      drawLedgerLine(stave.getYForNote(line));
    }
  }</pre></div>
        
      
        
        <p>Draw all key modifiers</p>

        
          <div class='highlight'><pre>  drawModifiers() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoCanvasContext'</span>, <span class="hljs-string">"Can't draw without a canvas context."</span>);
    }

    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>.context;
    ctx.openGroup(<span class="hljs-string">'modifiers'</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.modifiers.length; i++) {
      <span class="hljs-keyword">const</span> modifier = <span class="hljs-keyword">this</span>.modifiers[i];
      <span class="hljs-keyword">const</span> notehead = <span class="hljs-keyword">this</span>.note_heads[modifier.getIndex()];
      <span class="hljs-keyword">const</span> noteheadStyle = notehead.getStyle();
      <span class="hljs-keyword">if</span> (noteheadStyle) {
        ctx.save();
        notehead.applyStyle(ctx);
      }
      modifier.setContext(ctx);
      modifier.draw();
      <span class="hljs-keyword">if</span> (noteheadStyle) {
        ctx.restore();
      }
    }
    ctx.closeGroup();
  }</pre></div>
        
      
        
        <p>Draw the flag for the note</p>

        
          <div class='highlight'><pre>  drawFlag() {
    <span class="hljs-keyword">const</span> { stem, beam, context: ctx } = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">if</span> (!ctx) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoCanvasContext'</span>, <span class="hljs-string">"Can't draw without a canvas context."</span>);
    }

    <span class="hljs-keyword">const</span> shouldRenderFlag = beam === <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> glyph = <span class="hljs-keyword">this</span>.getGlyph();

    <span class="hljs-keyword">if</span> (glyph.flag &amp;&amp; shouldRenderFlag) {
      <span class="hljs-keyword">const</span> { y_top, y_bottom } = <span class="hljs-keyword">this</span>.getNoteHeadBounds();
      <span class="hljs-keyword">const</span> noteStemHeight = stem.getHeight();
      <span class="hljs-keyword">const</span> flagX = <span class="hljs-keyword">this</span>.getStemX();</pre></div>
        
      
        
        <p>FIXME: What’s with the magic +/- 2</p>

        
          <div class='highlight'><pre>      <span class="hljs-keyword">const</span> flagY = <span class="hljs-keyword">this</span>.getStemDirection() === Stem.DOWN</pre></div>
        
      
        
        <p>Down stems have flags on the left</p>

        
          <div class='highlight'><pre>          ? y_top - noteStemHeight + <span class="hljs-number">2</span></pre></div>
        
      
        
        <p>Up stems have flags on the eft.</p>

        
          <div class='highlight'><pre>          : y_bottom - noteStemHeight - <span class="hljs-number">2</span>;</pre></div>
        
      
        
        <p>Draw the Flag</p>

        
          <div class='highlight'><pre>      ctx.openGroup(<span class="hljs-string">'flag'</span>, <span class="hljs-literal">null</span>, { pointerBBox: <span class="hljs-literal">true</span> });
      <span class="hljs-keyword">this</span>.flag.render(ctx, flagX, flagY);
      ctx.closeGroup();
    }
  }</pre></div>
        
      
        
        <p>Draw the NoteHeads</p>

        
          <div class='highlight'><pre>  drawNoteHeads() {
    <span class="hljs-keyword">this</span>.note_heads.forEach(notehead =&gt; {
      <span class="hljs-keyword">this</span>.context.openGroup(<span class="hljs-string">'notehead'</span>, <span class="hljs-literal">null</span>, { pointerBBox: <span class="hljs-literal">true</span> });
      notehead.setContext(<span class="hljs-keyword">this</span>.context).draw();
      <span class="hljs-keyword">this</span>.context.closeGroup();
    });
  }</pre></div>
        
      
        
        <p>Render the stem onto the canvas</p>

        
          <div class='highlight'><pre>  drawStem(stemStruct) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoCanvasContext'</span>, <span class="hljs-string">"Can't draw without a canvas context."</span>);
    }

    <span class="hljs-keyword">if</span> (stemStruct) {
      <span class="hljs-keyword">this</span>.setStem(<span class="hljs-keyword">new</span> Stem(stemStruct));
    }

    <span class="hljs-keyword">this</span>.context.openGroup(<span class="hljs-string">'stem'</span>, <span class="hljs-literal">null</span>, { pointerBBox: <span class="hljs-literal">true</span> });
    <span class="hljs-keyword">this</span>.stem.setContext(<span class="hljs-keyword">this</span>.context).draw();
    <span class="hljs-keyword">this</span>.context.closeGroup();
  }</pre></div>
        
      
        
        <p>Draws all the <code>StaveNote</code> parts. This is the main drawing method.</p>

        
          <div class='highlight'><pre>  draw() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.context) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoCanvasContext'</span>, <span class="hljs-string">"Can't draw without a canvas context."</span>);
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stave) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoStave'</span>, <span class="hljs-string">"Can't draw without a stave."</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ys.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Vex.RERR(<span class="hljs-string">'NoYValues'</span>, <span class="hljs-string">"Can't draw note without Y values."</span>);
    }

    <span class="hljs-keyword">const</span> xBegin = <span class="hljs-keyword">this</span>.getNoteHeadBeginX();
    <span class="hljs-keyword">const</span> shouldRenderStem = <span class="hljs-keyword">this</span>.hasStem() &amp;&amp; !<span class="hljs-keyword">this</span>.beam;</pre></div>
        
      
        
        <p>Format note head x positions</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.note_heads.forEach(notehead =&gt; notehead.setX(xBegin));</pre></div>
        
      
        
        <p>Format stem x positions</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">const</span> stemX = <span class="hljs-keyword">this</span>.getStemX();
    <span class="hljs-keyword">this</span>.stem.setNoteHeadXBounds(stemX, stemX);

    L(<span class="hljs-string">'Rendering '</span>, <span class="hljs-keyword">this</span>.isChord() ? <span class="hljs-string">'chord :'</span> : <span class="hljs-string">'note :'</span>, <span class="hljs-keyword">this</span>.keys);</pre></div>
        
      
        
        <p>Draw each part of the note</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">this</span>.drawLedgerLines();

    <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">'el'</span>, <span class="hljs-keyword">this</span>.context.openGroup(<span class="hljs-string">'stavenote'</span>, <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">'id'</span>)));
    <span class="hljs-keyword">this</span>.context.openGroup(<span class="hljs-string">'note'</span>, <span class="hljs-literal">null</span>, { pointerBBox: <span class="hljs-literal">true</span> });
    <span class="hljs-keyword">if</span> (shouldRenderStem) <span class="hljs-keyword">this</span>.drawStem();
    <span class="hljs-keyword">this</span>.drawNoteHeads();
    <span class="hljs-keyword">this</span>.drawFlag();
    <span class="hljs-keyword">this</span>.context.closeGroup();
    <span class="hljs-keyword">this</span>.drawModifiers();
    <span class="hljs-keyword">this</span>.context.closeGroup();
    <span class="hljs-keyword">this</span>.setRendered();
  }
}</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
